<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Basic Tree Data Structure Operations in JAVA</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Basic Tree Data Structure Operations in JAVA</h1>
</header>
<section data-field="subtitle" class="p-summary">
Tree data structures are useful because they allow you to store and organize data hierarchically and logically. It is used for the…
</section>
<section data-field="body" class="e-content">
<section name="c447" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="29ef" id="29ef" class="graf graf--h3 graf--leading graf--title">Basic Tree Data Structure Operations in JAVA</h3><figure name="527f" id="527f" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*pSOghJ_L7Gk1AXoi" data-width="5472" data-height="3648" data-unsplash-photo-id="7EqQ1s3wIAI" src="https://cdn-images-1.medium.com/max/800/0*pSOghJ_L7Gk1AXoi"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@tbzr?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@tbzr?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener" target="_blank">Arnaud Mesureur</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener" target="_blank">Unsplash</a></figcaption></figure><p name="f599" id="f599" class="graf graf--p graf-after--figure">Tree data structures are useful because they allow you to store and organize data hierarchically and logically. It is used for the following reasons:</p><ul class="postList"><li name="b619" id="b619" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Effective data searching and sorting</strong></li><li name="272e" id="272e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Simple insertion and deletion</strong></li><li name="bf5e" id="bf5e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Organization and hierarchy</strong></li><li name="e91a" id="e91a" class="graf graf--li graf-after--li graf--trailing"><strong class="markup--strong markup--li-strong">Recursive algorithms</strong></li></ul></div></div></section><section name="c067" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="dbb4" id="dbb4" class="graf graf--p graf--leading">In this article, let&#39;s explore the different operations of a tree data structure. To start with, create a Java class representing a Tree Data Structure:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="java" name="06ec" id="06ec" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> {<br />    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> data;<br />    <span class="hljs-keyword">public</span> Node leftNode;<br />    <span class="hljs-keyword">public</span> Node rightNode;<br />    <br />    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> {<br />        <span class="hljs-built_in">this</span>.data=data;<br />    }<br />}</span></pre><h3 name="a893" id="a893" class="graf graf--h3 graf-after--pre">Different operations on a Tree:</h3><p name="b83f" id="b83f" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">1. In-order traversal</strong>: In this type of tree traversal, we will visit each node in <code class="markup--code markup--p-code">Left -&gt; Parent -&gt; Right</code> order. In the case of a BST (Binary Search Tree), it prints the node data in increasing order. This type of traversal is useful for tasks like expression evaluation, sorting, or searching.</p><p name="f293" id="f293" class="graf graf--p graf-after--p">Here, we can flatten the tree into the original sequence, which is not possible in Pre-order or Post-order traversal.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="scss" name="ca62" id="ca62" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><br />     static void <span class="hljs-built_in">inorderTraversal</span>(Node node) {<br />         <span class="hljs-comment">// Base case</span><br />         if (node == null)<br />             return;<br /> <br />         <span class="hljs-comment">// Traverse the left subtree</span><br />         <span class="hljs-built_in">inorderTraversal</span>(node.leftNode);<br /> <br />         <span class="hljs-comment">// Visit the current node</span><br />         System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.print</span>(node.data + &quot; &quot;);<br /> <br />         <span class="hljs-comment">// Traverse the right subtree</span><br />         <span class="hljs-built_in">inorderTraversal</span>(node.rightNode);<br />     }</span></pre><p name="1c28" id="1c28" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">2. Pre-order Traversal: </strong>In this type of tree traversal, we will visit each node in <code class="markup--code markup--p-code">Parent -&gt; Left -&gt; Right</code> order. Used when we need to process or print the nodes of a tree in a specific order.</p><p name="c821" id="c821" class="graf graf--p graf-after--p">You can use it to create a copy of a Tree.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="scss" name="fe12" id="fe12" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">static void <span class="hljs-built_in">preOrderTraversal</span>(Node node) {<br /> <br />         <span class="hljs-comment">// Base case</span><br />         if (node == null)<br />             return;<br /> <br /> <br />         <span class="hljs-comment">// Visit the current node</span><br />         System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.print</span>(node.data + &quot; &quot;);<br />         <span class="hljs-comment">// Traverse the left subtree</span><br />         <span class="hljs-built_in">preOrderTraversal</span>(node.leftNode);<br /> <br />         <span class="hljs-comment">// Traverse the right subtree</span><br />         <span class="hljs-built_in">preOrderTraversal</span>(node.rightNode);<br />     }</span></pre><p name="5661" id="5661" class="graf graf--p graf--empty graf-after--pre"><br></p><p name="acfe" id="acfe" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">3. Post-order traversal: </strong>In this type of tree traversal, we will visit each node in <code class="markup--code markup--p-code">Left -&gt; Right -&gt; Parent</code> order. It is also called the <strong class="markup--strong markup--p-strong">Depth-First Search (DFS) algorithm</strong> which visits the leaf nodes before the parent node. </p><p name="49ee" id="49ee" class="graf graf--p graf-after--p">Its primary use is <strong class="markup--strong markup--p-strong">to delete</strong> the tree, as we need to delete subtrees before deleting the current node.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="scss" name="d1a7" id="d1a7" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">static void <span class="hljs-built_in">postOrderTraversal</span>(Node node) {<br /> <br />         <span class="hljs-comment">// Base case</span><br />         if (node == null)<br />             return;<br /> <br />         <span class="hljs-comment">// Traverse the left subtree</span><br />         <span class="hljs-built_in">postOrderTraversal</span>(node.leftNode);<br /> <br />         <span class="hljs-comment">// Traverse the right subtree</span><br />         <span class="hljs-built_in">postOrderTraversal</span>(node.rightNode);<br /> <br />         <span class="hljs-comment">// Visit the current node</span><br />         System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.print</span>(node.data + &quot; &quot;);<br /> <br />     }</span></pre><p name="46a7" id="46a7" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">4. Level-Order traversal: </strong>In this type of tree traversal, we will visit nodes level-wise, i.e., starting from the root node, all sibling nodes are visited left to right before proceeding with respective child nodes. So, it is also called <strong class="markup--strong markup--p-strong">Breadth-First Search (BFS)</strong>.</p><p name="e7ce" id="e7ce" class="graf graf--p graf-after--p">It is used when we need to find the shortest path.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="csharp" name="5940" id="5940" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"> <br />     <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">levelOrderTraversal</span>(<span class="hljs-params">Node root</span>)</span> { <span class="hljs-comment">// Breadth-First Search done using Queue</span><br />         <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br /> <br />         Queue&lt;Node&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br />         q.<span class="hljs-keyword">add</span>(root);<br /> <br />         <span class="hljs-keyword">while</span> (!q.isEmpty()) {<br />             Node curr = q.poll();<br />             System.<span class="hljs-keyword">out</span>.print(curr.data + <span class="hljs-string">&quot; &quot;</span>);<br /> <br />             <span class="hljs-keyword">if</span> (curr.leftNode != <span class="hljs-literal">null</span>) q.<span class="hljs-keyword">add</span>(curr.leftNode);<br />             <span class="hljs-keyword">if</span> (curr.rightNode != <span class="hljs-literal">null</span>) q.<span class="hljs-keyword">add</span>(curr.rightNode);<br />         }<br />     }</span></pre><p name="033e" id="033e" class="graf graf--p graf-after--pre">Invoke these functions:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="java" name="f7d5" id="f7d5" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">   <br />         <span class="hljs-comment">// Traverse below tree:</span><br />         <span class="hljs-comment">//           1</span><br />         <span class="hljs-comment">//        /    \</span><br />         <span class="hljs-comment">//       2      3</span><br />         <span class="hljs-comment">//      / \      \</span><br />         <span class="hljs-comment">//     4   5      6       </span><br /> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {<br /> <br />     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br />         <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br />         root.leftNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">2</span>);<br />         root.rightNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">3</span>);<br />         root.leftNode.leftNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">4</span>);<br />         root.leftNode.rightNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">5</span>);<br />         root.rightNode.rightNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">6</span>);<br />         System.out.println(<span class="hljs-string">&quot;inorderTraversal: ---&gt; &quot;</span>);<br />         inorderTraversal(root); <span class="hljs-comment">// output: 4 2 5 1 3 6</span><br />         System.out.println(<span class="hljs-string">&quot;\npreOrderTraversal: ---&gt; &quot;</span>);<br />         preOrderTraversal(root); <span class="hljs-comment">// output: 1 2 4 5 3 6</span><br />         System.out.println(<span class="hljs-string">&quot;\npostOrderTraversal: ---&gt; &quot;</span>);<br />         postOrderTraversal(root); <span class="hljs-comment">// output: 4 5 2 6 3 1</span><br />         System.out.println(<span class="hljs-string">&quot;\nlevelOrderTraversal: ---&gt; &quot;</span>);<br />         levelOrderTraversal(root); <span class="hljs-comment">// output: 1 2 3 4 5 6</span><br />      }</span></pre><p name="eda1" id="eda1" class="graf graf--p graf-after--pre">Results:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="lua" name="ca5f" id="ca5f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">inorderTraversal: <span class="hljs-comment">---&gt; </span><br /><span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <br />preOrderTraversal: <span class="hljs-comment">---&gt; </span><br /><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <br />postOrderTraversal: <span class="hljs-comment">---&gt; </span><br /><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <br />levelOrderTraversal: <span class="hljs-comment">---&gt; </span><br /><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> </span></pre><p name="bb06" id="bb06" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">5. Add the element to the first available position:</strong></p><p name="b756" id="b756" class="graf graf--p graf-after--p">Example Tree:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="e348" id="e348" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">         <span class="hljs-comment">// existing Tree</span><br />         <span class="hljs-comment">//          10</span><br />         <span class="hljs-comment">//        /    \<br />         //       11     9</span><br />         <span class="hljs-comment">//      /      / \<br />         //     7      15   8</span><br /> <br />         <span class="hljs-comment">// after adding, tree will become</span><br />         <span class="hljs-comment">//          10</span><br />         <span class="hljs-comment">//        /    \<br />         //       11     9</span><br />         <span class="hljs-comment">//      /  \   / \<br />         //     7   12 15  8</span></span></pre><p name="0c0e" id="0c0e" class="graf graf--p graf-after--pre">Implementation:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="csharp" name="0480" id="0480" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><br /> <br />     <span class="hljs-function"><span class="hljs-keyword">static</span> Node <span class="hljs-title">insertNode</span>(<span class="hljs-params">Node root, <span class="hljs-built_in">int</span> data</span>)</span> {<br /> <br />         <span class="hljs-comment">// If the tree is empty, assign new node</span><br />         <span class="hljs-comment">// address to root</span><br />         <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) {<br />             root = <span class="hljs-keyword">new</span> Node(data);<br />             <span class="hljs-keyword">return</span> root;<br />         }<br /> <br />         <span class="hljs-comment">// Else, do level order traversal until we find an empty</span><br />         <span class="hljs-comment">// place, i.e. either left child or right child of some</span><br />         <span class="hljs-comment">// node is pointing to NULL.</span><br />         Queue&lt;Node&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br />         q.<span class="hljs-keyword">add</span>(root);<br /> <br />         <span class="hljs-keyword">while</span> (!q.isEmpty()) {<br /> <br />             <span class="hljs-comment">// Fron a front element in queue</span><br />             Node curr = q.poll();<br /> <br />             <span class="hljs-comment">// First check left if left is null insert</span><br />             <span class="hljs-comment">// node in left otherwise check for right</span><br />             <span class="hljs-keyword">if</span> (curr.leftNode != <span class="hljs-literal">null</span>)<br />                 q.<span class="hljs-keyword">add</span>(curr.leftNode);<br />             <span class="hljs-keyword">else</span> {<br />                 curr.leftNode = <span class="hljs-keyword">new</span> Node(data);<br />                 <span class="hljs-keyword">return</span> root;<br />             }<br /> <br />             <span class="hljs-keyword">if</span> (curr.rightNode != <span class="hljs-literal">null</span>)<br />                 q.<span class="hljs-keyword">add</span>(curr.rightNode);<br />             <span class="hljs-keyword">else</span> {<br />                 curr.rightNode = <span class="hljs-keyword">new</span> Node(data);<br />                 <span class="hljs-keyword">return</span> root;<br />             }<br />         }<br />         <span class="hljs-keyword">return</span> root;<br />     }</span></pre><p name="d458" id="d458" class="graf graf--p graf--empty graf-after--pre"><br></p><p name="6020" id="6020" class="graf graf--p graf-after--p">Invoke it as below:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="csharp" name="57c6" id="57c6" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {<br /> <br />     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> {<br />         Node rootNode = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">10</span>);<br />         rootNode.leftNode = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">11</span>);<br />         rootNode.rightNode = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">9</span>);<br />         rootNode.leftNode.leftNode = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">7</span>);<br />         rootNode.rightNode.leftNode = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">15</span>);<br />         rootNode.rightNode.rightNode = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">8</span>);<br /> <br />         <span class="hljs-built_in">int</span> key = <span class="hljs-number">12</span>;<br />         System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;\nInsertNode :: Before adding&quot;</span>);<br />         <span class="hljs-comment">// print nodes before adding</span><br />         inorderTraversal(rootNode);<br />         root = InsertNode(rootNode, key);<br />         System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;\nInsertNode :: After adding&quot;</span>);<br />         <span class="hljs-comment">// print nodes after adding</span><br />         inorderTraversal(rootNode); <span class="hljs-comment">// // output: 7 11 12 10 15 9 8</span><br />    }</span></pre><p name="1387" id="1387" class="graf graf--p graf-after--pre graf--trailing">References: <a href="https://stackoverflow.com/questions/9456937/when-to-use-preorder-postorder-and-inorder-binary-search-tree-traversal-strate" data-href="https://stackoverflow.com/questions/9456937/when-to-use-preorder-postorder-and-inorder-binary-search-tree-traversal-strate" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://stackoverflow.com/questions/9456937/when-to-use-preorder-postorder-and-inorder-binary-search-tree-traversal-strate</a> </p></div></div></section><section name="ca38" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="65cc" id="65cc" class="graf graf--h3 graf--leading"><strong class="markup--strong markup--h3-strong">Binary Search Tree (BST):</strong> </h3><p name="1e7a" id="1e7a" class="graf graf--p graf-after--h3">This data structure is used for organizing and storing data in a sorted manner.</p><p name="f294" id="f294" class="graf graf--p graf-after--p">Each Node in this Tree will have at most 2 nodes with their values being in the order <code class="markup--code markup--p-code"> left &lt; parent &lt; right </code></p><p name="bda1" id="bda1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">1. Insert element to a BST :</strong></p><p name="14c5" id="14c5" class="graf graf--p graf-after--p">Example BST:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="44b2" id="44b2" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">         <span class="hljs-comment">// BST - binary search tree operations</span><br />         <span class="hljs-comment">//         100</span><br />         <span class="hljs-comment">//        /   \<br />         //       20   500</span><br />         <span class="hljs-comment">//      /  \<br />         //     10   30</span><br />         <span class="hljs-comment">// output will be as below:</span><br />         <span class="hljs-comment">//         100</span><br />         <span class="hljs-comment">//        /   \<br />         //       20   500</span><br />         <span class="hljs-comment">//      /  \<br />         //     10   30</span><br />         <span class="hljs-comment">//            \<br />         //            40</span></span></pre><p name="80d2" id="80d2" class="graf graf--p graf-after--pre">Implementation:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="java" name="630d" id="630d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><br />     <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">insertToBST</span><span class="hljs-params">(Node root, <span class="hljs-type">int</span> keyToInsert)</span> {<br />         <span class="hljs-keyword">if</span> (Objects.isNull(root)) {<br />             <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(keyToInsert);<br />         }<br /> <br />         <span class="hljs-keyword">if</span>(keyToInsert &lt; root.data) {<br />             root.leftNode = insertToBST(root.leftNode, keyToInsert);<br />         }<br />         <span class="hljs-keyword">else</span> {<br />             root.rightNode = insertToBST(root.rightNode, keyToInsert);<br />         }<br />         <span class="hljs-keyword">return</span> root;<br />     }</span></pre><p name="e5b4" id="e5b4" class="graf graf--p graf-after--pre">Invoke it as below:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="csharp" name="390d" id="390d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {<br /> <br />     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> {<br />         Node binaryRootNode = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">100</span>);<br />         binaryRootNode.leftNode = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">20</span>);<br />         binaryRootNode.rightNode = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">500</span>);<br />         binaryRootNode.leftNode.leftNode = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">10</span>);<br />         binaryRootNode.leftNode.rightNode = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">30</span>);<br /> <br />         <span class="hljs-built_in">int</span> keyToInsert = <span class="hljs-number">40</span>;<br /> <br />         System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;\nInsertNode to BST:: Before adding&quot;</span>);<br />         inorderTraversal(binaryRootNode); <span class="hljs-comment">// output: 10 20 30 100 500</span><br />         insertToBST(binaryRootNode, keyToInsert);<br />         System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;\nInsertNode to BST:: After adding&quot;</span>);<br />         inorderTraversal(binaryRootNode); <span class="hljs-comment">// output: 10 20 30 40 100 500</span><br />      }</span></pre><p name="9165" id="9165" class="graf graf--p graf-after--pre">Output:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="b4a7" id="b4a7" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">InsertNode to BST:: Before adding<br /><span class="hljs-number">10</span> <span class="hljs-number">20</span> <span class="hljs-number">30</span> <span class="hljs-number">100</span> <span class="hljs-number">500</span> <br />InsertNode to BST:: After adding<br /><span class="hljs-number">10</span> <span class="hljs-number">20</span> <span class="hljs-number">30</span> <span class="hljs-number">40</span> <span class="hljs-number">100</span> <span class="hljs-number">500</span> </span></pre><p name="2b2b" id="2b2b" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">2. Delete leaf node from BST</strong></p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="java" name="f712" id="f712" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">     <br /><span class="hljs-comment">// delete the leaf node if present      </span><br /><span class="hljs-keyword">static</span> Node <span class="hljs-title function_">deleteLeafNodeInBST</span><span class="hljs-params">(Node root, <span class="hljs-type">int</span> keyToDelete)</span> {<br />        <span class="hljs-keyword">if</span>(Objects.isNull(root)) {<br />            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br />        }<br />        <br />        <span class="hljs-comment">// check if leaf node and data matches</span><br />        <span class="hljs-keyword">if</span>(Objects.isNull(root.leftNode) &amp;&amp; Objects.isNull(root.rightNode) &amp;&amp; root.data == keyToDelete) {<br />            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br />        }<br /> <br />         <span class="hljs-keyword">if</span>(keyToDelete &lt; root.data) {<br />             <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> deleteLeafNodeInBST(root.leftNode, keyToDelete);<br />             <span class="hljs-keyword">if</span>(Objects.isNull(temp)) {<br />                 root.leftNode = <span class="hljs-literal">null</span>;<br />             }<br />             <span class="hljs-keyword">else</span> {<br />                 root.leftNode = temp;<br />             }<br />         }<br />         <span class="hljs-keyword">else</span> {<br />             <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span>  deleteLeafNodeInBST(root.rightNode, keyToDelete);<br />             <span class="hljs-keyword">if</span>(Objects.isNull(temp)) {<br />                 root.rightNode = <span class="hljs-literal">null</span>;<br />             }<br />             <span class="hljs-keyword">else</span> {<br />                 root.rightNode = temp;<br />             }             <br />         }<br />         <span class="hljs-keyword">return</span> root;        <br />     }</span></pre><p name="a255" id="a255" class="graf graf--p graf-after--pre">Invoke it as below:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="java" name="2005" id="2005" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// BST - delete Leaf Node In BST</span><br />         <span class="hljs-comment">//         100</span><br />         <span class="hljs-comment">//        /   \</span><br />         <span class="hljs-comment">//       20   500</span><br />         <span class="hljs-comment">//      /  \</span><br />         <span class="hljs-comment">//     10   30</span><br />         <span class="hljs-comment">// output will be as below:</span><br />         <span class="hljs-comment">//         100</span><br />         <span class="hljs-comment">//        /   \</span><br />         <span class="hljs-comment">//       20   500</span><br />         <span class="hljs-comment">//      /  </span><br />         <span class="hljs-comment">//     10   </span><br />         <span class="hljs-comment">//            </span><br /><br /><br /><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span><br />{<br /> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br />   <span class="hljs-type">Node</span> <span class="hljs-variable">binaryRootNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">100</span>);<br />   binaryRootNode.leftNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">20</span>);<br />   binaryRootNode.rightNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">500</span>);<br />   binaryRootNode.leftNode.leftNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">10</span>);<br />   binaryRootNode.leftNode.rightNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">30</span>);<br />  <br />   <span class="hljs-type">int</span> <span class="hljs-variable">keyToDelete</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br />  <br />   System.out.println(<span class="hljs-string">&quot;\nBefore Deleting leaf Node from BST&quot;</span>);<br />   inorderTraversal(binaryRootNode); <span class="hljs-comment">// output: 10 20 30 100 500 </span><br />   deleteLeafNodeInBST(binaryRootNode, keyToDelete);<br />   System.out.println(<span class="hljs-string">&quot;\nAfter Deleting leaf Node from BST&quot;</span>);<br />   inorderTraversal(binaryRootNode); <span class="hljs-comment">// output: 10 20 100 500 </span><br /> }<br />}</span></pre><p name="bf27" id="bf27" class="graf graf--p graf-after--pre">Output:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="csharp" name="6550" id="6550" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><br />Before Deleting leaf Node <span class="hljs-keyword">from</span> BST<br /><span class="hljs-number">10</span> <span class="hljs-number">20</span> <span class="hljs-number">30</span> <span class="hljs-number">100</span> <span class="hljs-number">500</span> <br />After Deleting leaf Node <span class="hljs-keyword">from</span> BST<br /><span class="hljs-number">10</span> <span class="hljs-number">20</span> <span class="hljs-number">100</span> <span class="hljs-number">500</span> </span></pre><p name="9c92" id="9c92" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">6c. Get minimum and maximum in BST:</strong></p><p name="e1bc" id="e1bc" class="graf graf--p graf-after--p">Do the inorder traversal and 1st element will the minimum and last will be the maximum value</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="csharp" name="fada" id="fada" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-function"><span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title">getValueInBST</span>(<span class="hljs-params">Node root</span>)</span> {<br /><br />        List&lt;Integer&gt; sortedOrder = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br /><br />        inorderTraversal(root, sortedOrder);<br /><br />        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;sortedOrder:&quot;</span>+sortedOrder);<br /><br />        <span class="hljs-keyword">return</span> sortedOrder;<br />    }</span></pre><p name="3469" id="3469" class="graf graf--p graf-after--pre">Invoke as below:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="csharp" name="7f8c" id="7f8c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">       <br /><br />        <span class="hljs-comment">// for below BST</span><br />        <span class="hljs-comment">//         100</span><br />        <span class="hljs-comment">//        /   \</span><br />        <span class="hljs-comment">//       20   500</span><br />        <span class="hljs-comment">//         \</span><br />        <span class="hljs-comment">//         30</span><br />        <span class="hljs-comment">//           \</span><br />        <span class="hljs-comment">//           40</span><br /><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> {<br />      List&lt;Integer&gt; nodeList = getValueInBST(binaryRootNode);<br />      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;minimum value node:&quot;</span>+nodeList.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>));<br />      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;maximum value node:&quot;</span>+nodeList.<span class="hljs-keyword">get</span>(nodeList.size()<span class="hljs-number">-1</span>));<br />}</span></pre><p name="765b" id="765b" class="graf graf--p graf-after--pre">Output:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="typescript" name="bbe3" id="bbe3" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">minimum value <span class="hljs-attr">node</span>:<span class="hljs-number">20</span><br />maximum value <span class="hljs-attr">node</span>:<span class="hljs-number">500</span></span></pre><p name="02bc" id="02bc" class="graf graf--p graf--empty graf-after--pre"><br></p><p name="d4ee" id="d4ee" class="graf graf--p graf-after--p">6d. Traversal of BST</p><p name="bf42" id="bf42" class="graf graf--p graf-after--p">References : <a href="https://www.geeksforgeeks.org/binary-search-tree-data-structure/" data-href="https://www.geeksforgeeks.org/binary-search-tree-data-structure/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://www.geeksforgeeks.org/binary-search-tree-data-structure/</a> </p><p name="e331" id="e331" class="graf graf--p graf-after--p">7. Balanced BST</p><p name="5795" id="5795" class="graf graf--p graf-after--p">References: <a href="https://www.geeksforgeeks.org/convert-normal-bst-balanced-bst/" data-href="https://www.geeksforgeeks.org/convert-normal-bst-balanced-bst/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://www.geeksforgeeks.org/convert-normal-bst-balanced-bst/</a> </p><p name="2b84" id="2b84" class="graf graf--p graf--empty graf-after--p"><br></p><p name="e114" id="e114" class="graf graf--p graf--empty graf-after--p"><br></p><p name="4160" id="4160" class="graf graf--p graf-after--p">Complete code:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="java" name="bff1" id="bff1" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><br /> <span class="hljs-keyword">import</span> java.util.LinkedList;<br /> <span class="hljs-keyword">import</span> java.util.Objects;<br /> <span class="hljs-keyword">import</span> java.util.Queue;<br /> <br /> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> {<br />    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> data;<br />    <span class="hljs-keyword">public</span> Node leftNode;<br />    <span class="hljs-keyword">public</span> Node rightNode;<br />    <br />    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> {<br />        <span class="hljs-built_in">this</span>.data=data;<br />    }<br />}<br /><br /> <br /> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {<br /> <br />     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br /> <br />         <span class="hljs-comment">// Traverse below tree:</span><br />         <span class="hljs-comment">//           1</span><br />         <span class="hljs-comment">//        /    \</span><br />         <span class="hljs-comment">//       2      3</span><br />         <span class="hljs-comment">//      / \      \</span><br />         <span class="hljs-comment">//     4   5      6</span><br /> <br />         <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br />         root.leftNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">2</span>);<br />         root.rightNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">3</span>);<br />         root.leftNode.leftNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">4</span>);<br />         root.leftNode.rightNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">5</span>);<br />         root.rightNode.rightNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">6</span>);<br />         System.out.println(<span class="hljs-string">&quot;inorderTraversal: ---&gt; &quot;</span>);<br />         inorderTraversal(root); <span class="hljs-comment">// output: 4 2 5 1 3 6</span><br />         System.out.println(<span class="hljs-string">&quot;\npreOrderTraversal: ---&gt; &quot;</span>);<br />         preOrderTraversal(root); <span class="hljs-comment">// output: 1 2 4 5 3 6</span><br />         System.out.println(<span class="hljs-string">&quot;\npostOrderTraversal: ---&gt; &quot;</span>);<br />         postOrderTraversal(root); <span class="hljs-comment">// output: 4 5 2 6 3 1</span><br />         System.out.println(<span class="hljs-string">&quot;\nlevelOrderTraversal: ---&gt; &quot;</span>);<br />         levelOrderTraversal(root); <span class="hljs-comment">// output: 1 2 3 4 5 6</span><br /> <br />         <span class="hljs-comment">// Add element to tree in first available position</span><br />         <span class="hljs-comment">//          10</span><br />         <span class="hljs-comment">//        /    \</span><br />         <span class="hljs-comment">//       11     9</span><br />         <span class="hljs-comment">//      /      / \</span><br />         <span class="hljs-comment">//     7      15   8</span><br /> <br />         <span class="hljs-comment">// after adding, tree will become</span><br />         <span class="hljs-comment">//          10</span><br />         <span class="hljs-comment">//        /    \</span><br />         <span class="hljs-comment">//       11     9</span><br />         <span class="hljs-comment">//      /  \   / \</span><br />         <span class="hljs-comment">//     7   12 15  8</span><br /> <br />         <span class="hljs-type">Node</span> <span class="hljs-variable">rootNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">10</span>);<br />         rootNode.leftNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">11</span>);<br />         rootNode.rightNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">9</span>);<br />         rootNode.leftNode.leftNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">7</span>);<br />         rootNode.rightNode.leftNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">15</span>);<br />         rootNode.rightNode.rightNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">8</span>);<br /> <br />         <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br />         System.out.println(<span class="hljs-string">&quot;\nInsertNode :: Before adding&quot;</span>);<br />         <span class="hljs-comment">// print nodes before adding</span><br />         inorderTraversal(rootNode);<br />         root = InsertNode(rootNode, key);<br />         System.out.println(<span class="hljs-string">&quot;\nInsertNode :: After adding&quot;</span>);<br />         <span class="hljs-comment">// print nodes after adding</span><br />         inorderTraversal(rootNode); <span class="hljs-comment">// // output: 7 11 12 10 15 9 8</span><br /> <br /> <br />         <span class="hljs-comment">// BST - binary search tree operations</span><br />         <span class="hljs-comment">// add new element</span><br />         <span class="hljs-comment">//         100</span><br />         <span class="hljs-comment">//        /   \</span><br />         <span class="hljs-comment">//       20   500</span><br />         <span class="hljs-comment">//      /  \</span><br />         <span class="hljs-comment">//     10   30</span><br />         <span class="hljs-comment">// output will be as below:</span><br />         <span class="hljs-comment">//         100</span><br />         <span class="hljs-comment">//        /   \</span><br />         <span class="hljs-comment">//       20   500</span><br />         <span class="hljs-comment">//      /  \</span><br />         <span class="hljs-comment">//     10   30</span><br />         <span class="hljs-comment">//            \</span><br />         <span class="hljs-comment">//            40</span><br />         <span class="hljs-type">Node</span> <span class="hljs-variable">binaryRootNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">100</span>);<br />         binaryRootNode.leftNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">20</span>);<br />         binaryRootNode.rightNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">500</span>);<br />         binaryRootNode.leftNode.leftNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">10</span>);<br />         binaryRootNode.leftNode.rightNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">30</span>);<br /> <br />         <span class="hljs-type">int</span> <span class="hljs-variable">keyToInsert</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br /> <br />         System.out.println(<span class="hljs-string">&quot;\nInsertNode to BST:: Before adding&quot;</span>);<br />         inorderTraversal(binaryRootNode); <span class="hljs-comment">// output: 10 20 30 100 500</span><br />         insertToBST(binaryRootNode, keyToInsert);<br />         System.out.println(<span class="hljs-string">&quot;\nInsertNode to BST:: After adding&quot;</span>);<br />         inorderTraversal(binaryRootNode); <span class="hljs-comment">// output: 10 20 30 40 100 500</span><br />     }<br /> <br />     <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">insertToBST</span><span class="hljs-params">(Node root, <span class="hljs-type">int</span> keyToInsert)</span> {<br />         <span class="hljs-keyword">if</span> (Objects.isNull(root)) {<br />             <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(keyToInsert);<br />         }<br /> <br />         <span class="hljs-keyword">if</span>(keyToInsert &lt; root.data) {<br />             root.leftNode = insertToBST(root.leftNode, keyToInsert);<br />         }<br />         <span class="hljs-keyword">else</span> {<br />             root.rightNode = insertToBST(root.rightNode, keyToInsert);<br />         }<br />         <span class="hljs-keyword">return</span> root;<br />     }<br /> <br />     <span class="hljs-comment">// Depth-First Search done using stack</span><br />     <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(Node node)</span> {<br />         <span class="hljs-comment">// Base case</span><br />         <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br />             <span class="hljs-keyword">return</span>;<br /> <br />         <span class="hljs-comment">// Recur on the left subtree</span><br />         inorderTraversal(node.leftNode);<br /> <br />         <span class="hljs-comment">// Visit the current node</span><br />         System.out.print(node.data + <span class="hljs-string">&quot; &quot;</span>);<br /> <br />         <span class="hljs-comment">// Recur on the right subtree</span><br />         inorderTraversal(node.rightNode);<br />     }<br /> <br />     <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrderTraversal</span><span class="hljs-params">(Node node)</span> {<br /> <br />         <span class="hljs-comment">// Base case</span><br />         <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br />             <span class="hljs-keyword">return</span>;<br /> <br /> <br />         <span class="hljs-comment">// Visit the current node</span><br />         System.out.print(node.data + <span class="hljs-string">&quot; &quot;</span>);<br />         <span class="hljs-comment">// Recur on the left subtree</span><br />         preOrderTraversal(node.leftNode);<br /> <br />         <span class="hljs-comment">// Recur on the right subtree</span><br />         preOrderTraversal(node.rightNode);<br />     }<br /> <br />     <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrderTraversal</span><span class="hljs-params">(Node node)</span> {<br /> <br />         <span class="hljs-comment">// Base case</span><br />         <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br />             <span class="hljs-keyword">return</span>;<br /> <br /> <br />         <span class="hljs-comment">// Recur on the left subtree</span><br />         postOrderTraversal(node.leftNode);<br /> <br />         <span class="hljs-comment">// Recur on the right subtree</span><br />         postOrderTraversal(node.rightNode);<br /> <br />         <span class="hljs-comment">// Visit the current node</span><br />         System.out.print(node.data + <span class="hljs-string">&quot; &quot;</span>);<br /> <br />     }<br /> <br />     <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">levelOrderTraversal</span><span class="hljs-params">(Node root)</span> { <span class="hljs-comment">// Breadth-First Search done using Queue</span><br />         <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br /> <br />         Queue&lt;Node&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br />         q.add(root);<br /> <br />         <span class="hljs-keyword">while</span> (!q.isEmpty()) {<br />             <span class="hljs-type">Node</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> q.poll();<br />             System.out.print(curr.data + <span class="hljs-string">&quot; &quot;</span>);<br /> <br />             <span class="hljs-keyword">if</span> (curr.leftNode != <span class="hljs-literal">null</span>) q.add(curr.leftNode);<br />             <span class="hljs-keyword">if</span> (curr.rightNode != <span class="hljs-literal">null</span>) q.add(curr.rightNode);<br />         }<br />     }<br /> <br /> <br /> <br />     <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">InsertNode</span><span class="hljs-params">(Node root, <span class="hljs-type">int</span> data)</span> {<br /> <br />         <span class="hljs-comment">// If the tree is empty, assign new node</span><br />         <span class="hljs-comment">// address to root</span><br />         <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) {<br />             root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(data);<br />             <span class="hljs-keyword">return</span> root;<br />         }<br /> <br />         <span class="hljs-comment">// Else, do level order traversal until we find an empty</span><br />         <span class="hljs-comment">// place, i.e. either left child or right child of some</span><br />         <span class="hljs-comment">// node is pointing to NULL.</span><br />         Queue&lt;Node&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br />         q.add(root);<br /> <br />         <span class="hljs-keyword">while</span> (!q.isEmpty()) {<br /> <br />             <span class="hljs-comment">// Fron a front element in queue</span><br />             <span class="hljs-type">Node</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> q.poll();<br /> <br />             <span class="hljs-comment">// First check left if left is null insert</span><br />             <span class="hljs-comment">// node in left otherwise check for right</span><br />             <span class="hljs-keyword">if</span> (curr.leftNode != <span class="hljs-literal">null</span>)<br />                 q.add(curr.leftNode);<br />             <span class="hljs-keyword">else</span> {<br />                 curr.leftNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(data);<br />                 <span class="hljs-keyword">return</span> root;<br />             }<br /> <br />             <span class="hljs-keyword">if</span> (curr.rightNode != <span class="hljs-literal">null</span>)<br />                 q.add(curr.rightNode);<br />             <span class="hljs-keyword">else</span> {<br />                 curr.rightNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(data);<br />                 <span class="hljs-keyword">return</span> root;<br />             }<br />         }<br />         <span class="hljs-keyword">return</span> root;<br />     }<br /> <br /> }</span></pre><p name="3658" id="3658" class="graf graf--p graf-after--pre">Complete result:</p><p name="a73c" id="a73c" class="graf graf--p graf--empty graf-after--p"><br></p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="yaml" name="479f" id="479f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-attr">inorderTraversal:</span> <span class="hljs-string">---&gt;</span> <br /><span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <br /><span class="hljs-attr">preOrderTraversal:</span> <span class="hljs-string">---&gt;</span> <br /><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <br /><span class="hljs-attr">postOrderTraversal:</span> <span class="hljs-string">---&gt;</span> <br /><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <br /><span class="hljs-attr">levelOrderTraversal:</span> <span class="hljs-string">---&gt;</span> <br /><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <br /><span class="hljs-attr">InsertNode ::</span> <span class="hljs-string">Before</span> <span class="hljs-string">adding</span><br /><span class="hljs-number">7</span> <span class="hljs-number">11</span> <span class="hljs-number">10</span> <span class="hljs-number">15</span> <span class="hljs-number">9</span> <span class="hljs-number">8</span> <br /><span class="hljs-attr">InsertNode ::</span> <span class="hljs-string">After</span> <span class="hljs-string">adding</span><br /><span class="hljs-number">7</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">10</span> <span class="hljs-number">15</span> <span class="hljs-number">9</span> <span class="hljs-number">8</span> <br /><span class="hljs-attr">InsertNode to BST::</span> <span class="hljs-string">Before</span> <span class="hljs-string">adding</span><br /><span class="hljs-number">10</span> <span class="hljs-number">20</span> <span class="hljs-number">30</span> <span class="hljs-number">100</span> <span class="hljs-number">500</span> <br /><span class="hljs-attr">InsertNode to BST::</span> <span class="hljs-string">After</span> <span class="hljs-string">adding</span><br /><span class="hljs-number">10</span> <span class="hljs-number">20</span> <span class="hljs-number">30</span> <span class="hljs-number">40</span> <span class="hljs-number">100</span> <span class="hljs-number">500</span></span></pre><p name="e0fd" id="e0fd" class="graf graf--p graf--empty graf-after--pre graf--trailing"><br></p></div></div></section>
</section>
<footer><p><a href="https://medium.com/p/dcab147df5fa">View original.</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 9, 2025.</p></footer></article></body></html>